# Шейдер

Шейдерная программа - это программа которая выполняется видеокартой\
Шейдерная программа состоит из:
1. вершинный шейдер
2. шейдер тесселяции
3. геометрический шейдер
4. шейдер растеризации
5. фрагментный шейдер

В нашем случае есть только:
1. Вершинный шейдер
2. Фрагментный шейдер

Причём, любая шейдерная программа запускает шейдеры в таком порядке,\
в каком они у меня записаны в списке сверху

Шейдеры пишутся на языке GLSL(GL Shaders Language)\
Этот язык си подобный\
Шейдеры можно писать в файле с любым расширением,\
Распространённые среди разработчиков являются(.vert, .frag, .glsl)

```glsl
#version 460 core
// любой шейдер начинается с этой строчки
// она указывает версию glsl
```

Версии glsl для разных версий openGL

| OpenGL |       GLSL        | в самом шейдере |
| :----: | :---------------: | :-------------: |
|  2.0   |       1.10        |       110       |
|  2.2   |       1.20        |       120       |
|  3.0   | 1.10, 1.20 и 1.30 |  110, 120, 130  |
|  3.1   |    1.30 и 1.40    |     130,140     |
|  3.2   |    1.40 и 1.50    |    140 и 150    |
|  3.3   |       3.30        |       330       |
|  4.0   |       4.00        |       400       |
|  4.1   |       4.10        |       410       |
|  4.2   |  от 1.40 до 4.20  |  от 140 до 420  |
|  4.6   |  от 1.40 до 4.60  |  от 140 до 460  |

я буду использовать последнию версию 460,\
т.к сегодня у едениц нет поддержки openGL 4.6 и glsl 460

Однако если вы делаете программу для всех видеокарт,\
то стоит использовать openGL 3.3 и glsl 330

Напомню версию openGL можно поменять в файле src/core/core.hpp
```cpp
4  // версия openGL(4.6)
5 constexpr unsigned short VERSION_MAJOR = 4;
6 constexpr unsigned short VERSION_MINOR = 6;
```

```glsl
layout (location = 0) in vec3 pos;
// дальше в шейдере идут атрибуты о них в следующей главе

// теперь про типы данных
1. наследованные из си:
bool, int, uint, float, double

// ветор это структура для хранения нескольких переменных
// в примере буква 'N' это кол-во переменных от 2 до 4
2. векторы:
bvecN - вектор типа bool
ivecN - вектор типа int
uvecN - вектор типа uint
vecN - вектор типа float
dvecN - вектор типа double

// Пример действий с вектором:

1.создание
vec3 color;
// создаёт ветор color равный vec3(0, 0, 0)

vec3 f_color = vec3(10, 2, 3);
// создаёт ветор color равный vec3(10, 2, 3)

2.работы с переменными вектора:
vec4 position;

position.x = 1;
position.y = 10;
position.z = 5;
position.w = -14;
// получаем вектор position равный vec4(1, 10, 5, -14)

position.xy = vec2(0, 0);
// получаем вектор position равный vec4(0, 0, 5, -14)

position.yzw = vec3(1, 0, 0);
// получаем вектор position равный vec4(0, 1, 0, 0)

3.матрицы:
mat2, mat3, mat4
mat2x2, mat2x3, mat2x4,
mat3x2, mat3x3, mat3x4,
mat4x2, mat4x3, mat4x4,
// про матрицы подробно в другой главе

out тип название //передаём
in тип название //принимаем
// с помощью этих команд мы можем передавать переменную из одного шейдера в другой
// в нашем случае это работает по принципу: 
// "Из вершинного в фрагментный, но не в обратную сторону" 

// главная функция есть в любом шейдере
void main()
{
    gl_Position - это встроенная переменая
    // она принимает координаты текущей вершины в виде vec4
    // с помощью этой переменной мы объясняем ГПУ где рисовать вершину
    // эта переменная может использоваться только в вершинном шейдере
}
```

+ По мере чтения руководства будут появляться новые функции для шейдеров

> [!TIP]
> Что бы хоть что то увидеть на экране,\
> нам надо скомпилировать шейдеры в шейдерную программу\
> и загрузить её в видеокарту\
> Как и в случае с vao шейдерные программы имеют\
> свои номера в памяти ГПУ

тут есть два способа работы с шейдерами:

+ первый способ

```cpp
shader::createFromFile(const char* pathVert, const char* pathFrag);
// функция принимает путь к вершинному и фрагментному шейдеру
// компилирует их в ГПУ, и возвращает(unsigned int) номер шейдерной программы

shader::use(unsigned int id);
// говорит ГПУ какой шейдер использовать, принимает номер шейдерной программы

shader::Delete(unsigned int id);
// удаляет шейдерную программу, принимает номер шейдерной программы

shader::DeleteALL();
// удаляет все шейдерные программы

// все функции которые ниже, позволяют передавать значения в переменные шейдера
shader::UniformMat4(glm::mat4 matrix, const char* name);
shader::Uniform1F(const float value, const char* name);
shader::Uniform2F(glm::vec2 vec2, const char* name);
shader::Uniform3F(glm::vec3 vec3, const char* name);
shader::Uniform4F(glm::vec4 vec4, const char* name);

shader::Uniform1I(glm::ivec1 value, const char* name);
shader::Uniform2I(glm::ivec2 value, const char* name);
```
для этого в шейдере создаются unifrom переменные\
**Пример**:
```glsl
uniform vec4 un_color;
vec4 color = un_color;
```

Далее в с++ мы используем такую функцию(или другую из списка):
```cpp
shader::Uniform4F(glm::vec4(1, 1, 1, 1), "un_color");
// этой функцией мы передали вектор glm::vec4(1, 1, 1, 1), в переменую color
```
Обратите внимания для работы с векторами и матрицами используется\
библиотека glm(далее я расскажу про матричные\
преобразования и библиотеку glm)

+ второй способ
```cpp
Shader shader(const char* pathVert, const char* pathFrag);
// конструктор принимает путь к вершинному и фрагментному шейдеру
// компилирует их в ГПУ, и создаёт объект shader(ну или с вашим названием)

shader.~Shader();
// деструктор удаляет шейдерную программу

shader.use();
// говорит ГПУ использовать данный шейдер

// делают всё тоже что и в первом способе:
shader.UniformMat4(glm::mat4 matrix, const char* name);
shader.Uniform1F(const float value, const char* name);
shader.Uniform2F(glm::vec2 vec2, const char* name);
shader.Uniform3F(glm::vec3 vec3, const char* name);
shader.Uniform4F(glm::vec4 vec4, const char* name);

shader.Uniform1I(glm::ivec1 value, const char* name);
shader.Uniform2I(glm::ivec2 value, const char* name);
```

+ [дальше](va.md)
+ [назад](vao.md) 
+ [в оглавление](manual.md)
